/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { constructionConstructionPayloads } from "../../funcs/constructionConstructionPayloads.js";
import * as models from "../../models/index.js";
import { formatResult, ToolDefinition } from "../tools.js";

const args = {
  request: models.ConstructionPayloadsRequest$inboundSchema,
};

export const tool$constructionConstructionPayloads: ToolDefinition<
  typeof args
> = {
  name: "construction-construction-payloads",
  description: `Generate an Unsigned Transaction and Signing Payloads

Payloads is called with an array of operations and the response from \`/construction/metadata\`. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType. The array of operations provided in transaction construction often times can not specify all "effects" of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the "intent" of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction.`,
  args,
  tool: async (client, args, ctx) => {
    const [result, apiCall] = await constructionConstructionPayloads(
      client,
      args.request,
      { fetchOptions: { signal: ctx.signal } },
    ).$inspect();

    if (!result.ok) {
      return {
        content: [{ type: "text", text: result.error.message }],
        isError: true,
      };
    }

    const value = result.value;

    return formatResult(value, apiCall);
  },
};
