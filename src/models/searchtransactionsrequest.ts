/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AccountIdentifier,
  AccountIdentifier$inboundSchema,
  AccountIdentifier$Outbound,
  AccountIdentifier$outboundSchema,
} from "./accountidentifier.js";
import {
  CoinIdentifier,
  CoinIdentifier$inboundSchema,
  CoinIdentifier$Outbound,
  CoinIdentifier$outboundSchema,
} from "./coinidentifier.js";
import {
  Currency,
  Currency$inboundSchema,
  Currency$Outbound,
  Currency$outboundSchema,
} from "./currency.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  NetworkIdentifier,
  NetworkIdentifier$inboundSchema,
  NetworkIdentifier$Outbound,
  NetworkIdentifier$outboundSchema,
} from "./networkidentifier.js";
import {
  Operator,
  Operator$inboundSchema,
  Operator$outboundSchema,
} from "./operator.js";
import {
  TransactionIdentifier,
  TransactionIdentifier$inboundSchema,
  TransactionIdentifier$Outbound,
  TransactionIdentifier$outboundSchema,
} from "./transactionidentifier.js";

/**
 * SearchTransactionsRequest is used to search for transactions matching a set of provided conditions in canonical blocks.
 */
export type SearchTransactionsRequest = {
  /**
   * The network_identifier specifies which network a particular object is associated with.
   */
  networkIdentifier: NetworkIdentifier;
  /**
   * Operator is used by query-related endpoints to determine how to apply conditions. If this field is not populated, the default `and` value will be used.
   */
  operator?: Operator | undefined;
  /**
   * max_block is the largest block index to consider when searching for transactions. If this field is not populated, the current block is considered the max_block. If you do not specify a max_block, it is possible a newly synced block will interfere with paginated transaction queries (as the offset could become invalid with newly added rows).
   */
  maxBlock?: number | undefined;
  /**
   * offset is the offset into the query result to start returning transactions. If any search conditions are changed, the query offset will change and you must restart your search iteration.
   */
  offset?: number | undefined;
  /**
   * limit is the maximum number of transactions to return in one call. The implementation may return <= limit transactions.
   */
  limit?: number | undefined;
  /**
   * The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
   */
  transactionIdentifier?: TransactionIdentifier | undefined;
  /**
   * The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
   */
  accountIdentifier?: AccountIdentifier | undefined;
  /**
   * CoinIdentifier uniquely identifies a Coin.
   */
  coinIdentifier?: CoinIdentifier | undefined;
  /**
   * Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
   */
  currency?: Currency | undefined;
  /**
   * status is the network-specific operation type.
   */
  status?: string | undefined;
  /**
   * type is the network-specific operation type.
   */
  type?: string | undefined;
  /**
   * address is AccountIdentifier.Address. This is used to get all transactions related to an AccountIdentifier.Address, regardless of SubAccountIdentifier.
   */
  address?: string | undefined;
  /**
   * success is a synthetic condition populated by parsing network-specific operation statuses (using the mapping provided in `/network/options`).
   */
  success?: boolean | undefined;
};

/** @internal */
export const SearchTransactionsRequest$inboundSchema: z.ZodType<
  SearchTransactionsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  network_identifier: NetworkIdentifier$inboundSchema,
  operator: Operator$inboundSchema.optional(),
  max_block: z.number().int().optional(),
  offset: z.number().int().optional(),
  limit: z.number().int().optional(),
  transaction_identifier: TransactionIdentifier$inboundSchema.optional(),
  account_identifier: AccountIdentifier$inboundSchema.optional(),
  coin_identifier: CoinIdentifier$inboundSchema.optional(),
  currency: Currency$inboundSchema.optional(),
  status: z.string().optional(),
  type: z.string().optional(),
  address: z.string().optional(),
  success: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "network_identifier": "networkIdentifier",
    "max_block": "maxBlock",
    "transaction_identifier": "transactionIdentifier",
    "account_identifier": "accountIdentifier",
    "coin_identifier": "coinIdentifier",
  });
});

/** @internal */
export type SearchTransactionsRequest$Outbound = {
  network_identifier: NetworkIdentifier$Outbound;
  operator?: string | undefined;
  max_block?: number | undefined;
  offset?: number | undefined;
  limit?: number | undefined;
  transaction_identifier?: TransactionIdentifier$Outbound | undefined;
  account_identifier?: AccountIdentifier$Outbound | undefined;
  coin_identifier?: CoinIdentifier$Outbound | undefined;
  currency?: Currency$Outbound | undefined;
  status?: string | undefined;
  type?: string | undefined;
  address?: string | undefined;
  success?: boolean | undefined;
};

/** @internal */
export const SearchTransactionsRequest$outboundSchema: z.ZodType<
  SearchTransactionsRequest$Outbound,
  z.ZodTypeDef,
  SearchTransactionsRequest
> = z.object({
  networkIdentifier: NetworkIdentifier$outboundSchema,
  operator: Operator$outboundSchema.optional(),
  maxBlock: z.number().int().optional(),
  offset: z.number().int().optional(),
  limit: z.number().int().optional(),
  transactionIdentifier: TransactionIdentifier$outboundSchema.optional(),
  accountIdentifier: AccountIdentifier$outboundSchema.optional(),
  coinIdentifier: CoinIdentifier$outboundSchema.optional(),
  currency: Currency$outboundSchema.optional(),
  status: z.string().optional(),
  type: z.string().optional(),
  address: z.string().optional(),
  success: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    networkIdentifier: "network_identifier",
    maxBlock: "max_block",
    transactionIdentifier: "transaction_identifier",
    accountIdentifier: "account_identifier",
    coinIdentifier: "coin_identifier",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchTransactionsRequest$ {
  /** @deprecated use `SearchTransactionsRequest$inboundSchema` instead. */
  export const inboundSchema = SearchTransactionsRequest$inboundSchema;
  /** @deprecated use `SearchTransactionsRequest$outboundSchema` instead. */
  export const outboundSchema = SearchTransactionsRequest$outboundSchema;
  /** @deprecated use `SearchTransactionsRequest$Outbound` instead. */
  export type Outbound = SearchTransactionsRequest$Outbound;
}

export function searchTransactionsRequestToJSON(
  searchTransactionsRequest: SearchTransactionsRequest,
): string {
  return JSON.stringify(
    SearchTransactionsRequest$outboundSchema.parse(searchTransactionsRequest),
  );
}

export function searchTransactionsRequestFromJSON(
  jsonString: string,
): SafeParseResult<SearchTransactionsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchTransactionsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchTransactionsRequest' from JSON`,
  );
}
