/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  CurveType,
  CurveType$inboundSchema,
  CurveType$outboundSchema,
} from "./curvetype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * PublicKey contains a public key byte array for a particular CurveType encoded in hex. Note that there is no PrivateKey struct as this is NEVER the concern of an implementation.
 */
export type PublicKey = {
  /**
   * Hex-encoded public key bytes in the format specified by the CurveType.
   */
  hexBytes: string;
  /**
   * CurveType is the type of cryptographic curve associated with a PublicKey. * secp256k1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3) * secp256k1_bip340: x-only - `32 bytes`  (implicitly even `Y` coord. Secp256k1 compressed keys may be repurposed by dropping the first byte. (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Public_Key_Generation)) * secp256r1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3) * edwards25519: `y (255-bits) || x-sign-bit (1-bit)` - `32 bytes` (https://ed25519.cr.yp.to/ed25519-20110926.pdf) * tweedle: 1st pk : Fq.t (32 bytes) || 2nd pk : Fq.t (32 bytes) (https://github.com/CodaProtocol/coda/blob/develop/rfcs/0038-rosetta-construction-api.md#marshal-keys) * pallas: `x (255 bits) || y-parity-bit (1-bit) - 32 bytes` (https://github.com/zcash/pasta)
   */
  curveType: CurveType;
};

/** @internal */
export const PublicKey$inboundSchema: z.ZodType<
  PublicKey,
  z.ZodTypeDef,
  unknown
> = z.object({
  hex_bytes: z.string(),
  curve_type: CurveType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "hex_bytes": "hexBytes",
    "curve_type": "curveType",
  });
});

/** @internal */
export type PublicKey$Outbound = {
  hex_bytes: string;
  curve_type: string;
};

/** @internal */
export const PublicKey$outboundSchema: z.ZodType<
  PublicKey$Outbound,
  z.ZodTypeDef,
  PublicKey
> = z.object({
  hexBytes: z.string(),
  curveType: CurveType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    hexBytes: "hex_bytes",
    curveType: "curve_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PublicKey$ {
  /** @deprecated use `PublicKey$inboundSchema` instead. */
  export const inboundSchema = PublicKey$inboundSchema;
  /** @deprecated use `PublicKey$outboundSchema` instead. */
  export const outboundSchema = PublicKey$outboundSchema;
  /** @deprecated use `PublicKey$Outbound` instead. */
  export type Outbound = PublicKey$Outbound;
}

export function publicKeyToJSON(publicKey: PublicKey): string {
  return JSON.stringify(PublicKey$outboundSchema.parse(publicKey));
}

export function publicKeyFromJSON(
  jsonString: string,
): SafeParseResult<PublicKey, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PublicKey$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PublicKey' from JSON`,
  );
}
