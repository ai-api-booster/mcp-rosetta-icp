/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  PublicKey,
  PublicKey$inboundSchema,
  PublicKey$Outbound,
  PublicKey$outboundSchema,
} from "./publickey.js";
import {
  SignatureType,
  SignatureType$inboundSchema,
  SignatureType$outboundSchema,
} from "./signaturetype.js";
import {
  SigningPayload,
  SigningPayload$inboundSchema,
  SigningPayload$Outbound,
  SigningPayload$outboundSchema,
} from "./signingpayload.js";

/**
 * Signature contains the payload that was signed, the public keys of the keypairs used to produce the signature, the signature (encoded in hex), and the SignatureType. PublicKey is often times not known during construction of the signing payloads but may be needed to combine signatures properly.
 */
export type Signature = {
  /**
   * SigningPayload is signed by the client with the keypair associated with an AccountIdentifier using the specified SignatureType. SignatureType can be optionally populated if there is a restriction on the signature scheme that can be used to sign the payload.
   */
  signingPayload: SigningPayload;
  /**
   * PublicKey contains a public key byte array for a particular CurveType encoded in hex. Note that there is no PrivateKey struct as this is NEVER the concern of an implementation.
   */
  publicKey: PublicKey;
  /**
   * SignatureType is the type of a cryptographic signature. * ecdsa: `r (32-bytes) || s (32-bytes)` - `64 bytes` * ecdsa_recovery: `r (32-bytes) || s (32-bytes) || v (1-byte)` - `65 bytes` * ed25519: `R (32-byte) || s (32-bytes)` - `64 bytes` * schnorr_1: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (schnorr signature implemented by Zilliqa where both `r` and `s` are scalars encoded as `32-bytes` values, most significant byte first.) * schnorr_bip340: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (sig = (bytes(R) || bytes((k + ed) mod n) where `r` is the `X` coordinate of a point `R` whose `Y` coordinate is even, most significant bytes first.) * schnorr_poseidon: `r (32-bytes) || s (32-bytes)` where s = Hash(1st pk || 2nd pk || r) - `64 bytes`  (schnorr signature w/ Poseidon hash function implemented by O(1) Labs where both `r` and `s` are scalars encoded as `32-bytes` values, least significant byte first. https://github.com/CodaProtocol/signer-reference/blob/master/schnorr.ml )
   */
  signatureType: SignatureType;
  hexBytes: string;
};

/** @internal */
export const Signature$inboundSchema: z.ZodType<
  Signature,
  z.ZodTypeDef,
  unknown
> = z.object({
  signing_payload: SigningPayload$inboundSchema,
  public_key: PublicKey$inboundSchema,
  signature_type: SignatureType$inboundSchema,
  hex_bytes: z.string(),
}).transform((v) => {
  return remap$(v, {
    "signing_payload": "signingPayload",
    "public_key": "publicKey",
    "signature_type": "signatureType",
    "hex_bytes": "hexBytes",
  });
});

/** @internal */
export type Signature$Outbound = {
  signing_payload: SigningPayload$Outbound;
  public_key: PublicKey$Outbound;
  signature_type: string;
  hex_bytes: string;
};

/** @internal */
export const Signature$outboundSchema: z.ZodType<
  Signature$Outbound,
  z.ZodTypeDef,
  Signature
> = z.object({
  signingPayload: SigningPayload$outboundSchema,
  publicKey: PublicKey$outboundSchema,
  signatureType: SignatureType$outboundSchema,
  hexBytes: z.string(),
}).transform((v) => {
  return remap$(v, {
    signingPayload: "signing_payload",
    publicKey: "public_key",
    signatureType: "signature_type",
    hexBytes: "hex_bytes",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Signature$ {
  /** @deprecated use `Signature$inboundSchema` instead. */
  export const inboundSchema = Signature$inboundSchema;
  /** @deprecated use `Signature$outboundSchema` instead. */
  export const outboundSchema = Signature$outboundSchema;
  /** @deprecated use `Signature$Outbound` instead. */
  export type Outbound = Signature$Outbound;
}

export function signatureToJSON(signature: Signature): string {
  return JSON.stringify(Signature$outboundSchema.parse(signature));
}

export function signatureFromJSON(
  jsonString: string,
): SafeParseResult<Signature, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Signature$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Signature' from JSON`,
  );
}
