/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AccountIdentifier,
  AccountIdentifier$inboundSchema,
  AccountIdentifier$Outbound,
  AccountIdentifier$outboundSchema,
} from "./accountidentifier.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  SignatureType,
  SignatureType$inboundSchema,
  SignatureType$outboundSchema,
} from "./signaturetype.js";

/**
 * SigningPayload is signed by the client with the keypair associated with an AccountIdentifier using the specified SignatureType. SignatureType can be optionally populated if there is a restriction on the signature scheme that can be used to sign the payload.
 */
export type SigningPayload = {
  /**
   * [DEPRECATED by `account_identifier` in `v1.4.4`] The network-specific address of the account that should sign the payload.
   */
  address?: string | undefined;
  /**
   * The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
   */
  accountIdentifier?: AccountIdentifier | undefined;
  /**
   * Hex-encoded string of the payload bytes.
   */
  hexBytes: string;
  /**
   * SignatureType is the type of a cryptographic signature. * ecdsa: `r (32-bytes) || s (32-bytes)` - `64 bytes` * ecdsa_recovery: `r (32-bytes) || s (32-bytes) || v (1-byte)` - `65 bytes` * ed25519: `R (32-byte) || s (32-bytes)` - `64 bytes` * schnorr_1: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (schnorr signature implemented by Zilliqa where both `r` and `s` are scalars encoded as `32-bytes` values, most significant byte first.) * schnorr_bip340: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (sig = (bytes(R) || bytes((k + ed) mod n) where `r` is the `X` coordinate of a point `R` whose `Y` coordinate is even, most significant bytes first.) * schnorr_poseidon: `r (32-bytes) || s (32-bytes)` where s = Hash(1st pk || 2nd pk || r) - `64 bytes`  (schnorr signature w/ Poseidon hash function implemented by O(1) Labs where both `r` and `s` are scalars encoded as `32-bytes` values, least significant byte first. https://github.com/CodaProtocol/signer-reference/blob/master/schnorr.ml )
   */
  signatureType?: SignatureType | undefined;
};

/** @internal */
export const SigningPayload$inboundSchema: z.ZodType<
  SigningPayload,
  z.ZodTypeDef,
  unknown
> = z.object({
  address: z.string().optional(),
  account_identifier: AccountIdentifier$inboundSchema.optional(),
  hex_bytes: z.string(),
  signature_type: SignatureType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "account_identifier": "accountIdentifier",
    "hex_bytes": "hexBytes",
    "signature_type": "signatureType",
  });
});

/** @internal */
export type SigningPayload$Outbound = {
  address?: string | undefined;
  account_identifier?: AccountIdentifier$Outbound | undefined;
  hex_bytes: string;
  signature_type?: string | undefined;
};

/** @internal */
export const SigningPayload$outboundSchema: z.ZodType<
  SigningPayload$Outbound,
  z.ZodTypeDef,
  SigningPayload
> = z.object({
  address: z.string().optional(),
  accountIdentifier: AccountIdentifier$outboundSchema.optional(),
  hexBytes: z.string(),
  signatureType: SignatureType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    accountIdentifier: "account_identifier",
    hexBytes: "hex_bytes",
    signatureType: "signature_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SigningPayload$ {
  /** @deprecated use `SigningPayload$inboundSchema` instead. */
  export const inboundSchema = SigningPayload$inboundSchema;
  /** @deprecated use `SigningPayload$outboundSchema` instead. */
  export const outboundSchema = SigningPayload$outboundSchema;
  /** @deprecated use `SigningPayload$Outbound` instead. */
  export type Outbound = SigningPayload$Outbound;
}

export function signingPayloadToJSON(signingPayload: SigningPayload): string {
  return JSON.stringify(SigningPayload$outboundSchema.parse(signingPayload));
}

export function signingPayloadFromJSON(
  jsonString: string,
): SafeParseResult<SigningPayload, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SigningPayload$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SigningPayload' from JSON`,
  );
}
